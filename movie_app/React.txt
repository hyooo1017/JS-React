<< #1.2 리액트 작동 원리 >>
- react application에서 자바스크립트와 함께 만들어진 요소들을 HTML div(id 일치하는) 사이로 밀어넣음
	-> ReactDOM이 index.js에서 document.getElementById("")로 해당 id 위치에 App을 렌더함
		(리액트를 사용하면 웹페이지에서 F12/Sources 실행해도 기본적인 HTML 파일만 확인되고 리액트로 구성된 요소들을 확인할 수 없음)
- 리액트는 소스코드에 처음부터 HTML을 넣지 않고 기본 제공되는 index.html에 추가하거나 제거함
	-> 웹페이지를 로드할 때, 빈 HTML을 로드하고 그 후에 리액트가 컴포넌트를 작성해두었던 HTML을 밀어넣음
		(리액트 속도가 빠른 이유)
- virtual DOM(virtual document object model) : 존재하지 않는(소스코드에 보이지 않으므로) DOM


<< #2.0 Component(컴포넌트) >>
* 컴포넌트는 HTML을 반환하는 함수(ex. App.js의 App함수)
- ReactDOM.render(<~~~ />,~~);에서 <~~~ />가 컴포넌트에 해당됨 (JSX - 자바스크립트와 HTML의 조합, 리액트에 특화된 개념)
- 리액트는 컴포넌트로 동작됨 ( data를 보여주는 역할도 함 )

>> in JS 파일 <<
- React를 import하지 않으면 JSX가 있는 컴포넌트를 사용하는 것을 이해하지 못함
- 함수 이름은 대문자로 시작
- 함수를 export하지 않으면 아무도 이 컴포넌트를 사용하지 않음 (ex. Potato.js의 export default Potato;)
** 이 컴포넌트를 index.js에서 <App /> 옆에 호출하면 에러발생!!
	-> App을 이미 렌더하고 있기 때문에(하나의 컴포넌트만 렌더할 수 있음)
-> App 내부에 Potato를 넣어서 렌더하면 OK!

### react application은 한 번에 하나의 컴포넌트만 render할 수 있다 ###
=> 모든 것은 application 안에 들어가야 함
==> application 안에 많은 컴포넌트를 넣을 수 있음
===> 이러한 컴포넌트 안에 더 많은 컴포넌트를 import할 수 있음


<< #2.1 JSX >>
- 자바스크립트 안의 HYML
- 컴포넌트에 정보를 보낼 수 있음
- 재사용 가능한 컴포넌트를 만들 수 있음 (컴포넌트를 반복해서 사용할 수 있음)
** 컴포넌트 -> 컴포넌트 (자식 컴포넌트로) 정보를 보내는 방법
	1. App 컴포넌트에서 <Food fav="kimchi"/> 형식으로 (prop fav가 kimchi인)데이터를 보냄
		(Food 컴포넌트에 fav라는 이름의 property(이하 props)를 kimchi라는 value로 넘김)
		(text, boolean, array 등 다양한 형태의 데이터 넘길 수 있음)
	2. Food 컴포넌트에서 props(받은 데이터)를 인자로 받음
		(props의 내부에서 바로 fav 가져올 수 있음)


<< #2.2 map >
- array의 각 item에서 array를 반환하는 함수를 실행하는 자바스크립트 함수
	(ex 1)
		const friends = ["min", "yul", "jun", "eun"]
		friends.map(friend => {
			return friend + "♥";
		})
		▶ (4) ["min♥", "yul♥", "jun♥", "eun♥"]
=> array의 각 item에 함수 적용
==> 함수에 array를 전달
===> 따라서 map은 array를 취하고 원하는 array를 반환


<< #2.3 map2 >>
	(ex 2)
		function Food({ name, picture }){
			return (
				<div>
					<h2>I like {name}</h2>
					<img src={picture} alt={name}/>
				</div>
			);
		}
		function renderFood(dish){
			return <Food name={dish.name} picture={dish.image} />
		}
		const foodILike = [
			{
				name: "Kimchi",
				image: "..."
			},
			{
				name: "Samgyeopsal",
				image: "..."
			},
			{
				name: "Bibimbap",
				image: "..."
			},
			{
				name: "Doncatsu",
				image: "..."
			},
			{
				name: "Kimbap",
				image: "..."
			},
		]
		function App() {
			return (
				<div>
					{console.log(foodILike.map(renderFood))}
					{foodILike.map(renderFood)}
				</div>
			);
		}
		▼(5) [{…}, {…}, {…}, {…}, {…}]
		    ▶0: {$$typeof: Symbol(react.element), key: null, ref: null, props: {…}, type: ƒ, …} 
=> 기본적인 리액트 컴포넌트들을 array형식으로 확인할 수 있음
=> 이미지 요소는 alt prop이 반드시 있어야 함(이미지가 보이지 않을 때를 위한 대체 텍스트 지정)

>> in Web console <<
Warning: Each child in a list should have a unique "key" prop.
=> 리액트의 모든 element들은 유일해야 하는데 리스트에 담기면서 유일성을 잃어버림
==> foodILike의 item에 각각의 ID 추가
===> props에 key={dish.id} 추가(Food 컴포넌트에는 전달되지 않음 - 리액트 내부에서 사용)


<< #2.4 PropTypes >>
1. foodILike 배열객체 안에 rating(숫자) 추가
2. props에 rating 추가, Food 함수의 인자 및 내용 추가
3. npm i prop-types
	-> prop-types는 내가 전달받은 props가 내가 원하는 props인지 확인
4. import PropTypes from 'prop-types';
5. (ex) // 내가 얻고 싶은 props에 대한 설명을 적음
		Food.propTypes = {
			name: PropTypes.string.isRequired,
			picture: PropTypes.string.isRequired,
			rating: PropTypes.number.isRequired,
		}
		=> props value이름을 잘못 작성했다던지, 타입이 잘못되면 웹 콘솔(Warning)에서 확인 가능
		==> isRequired를 체크하지 않는다면 foodILike의 item에 해당 값이 필수가 아니라는 의미를 갖음
			(ex)
				const foodILike = [
					{
						id: 1,
						name: "Kimchi",
						image: "..."
					},
					{
						id: 2,
						name: "Samgyeopsal",
						image: "...",
						rating: 4.5
					},
					...
				]
				
				Food.propTypes = {
					name: PropTypes.string.isRequired,
					picture: PropTypes.string.isRequired,
					rating: PropTypes.number,
				}
				===> 첫 번째 item에 rating에 대한 값이 없지만 OK(rating이 isRequired로 체크되어 있지 않아서 필수값이 아니므로)
		====> https://ko.reactjs.org/docs/typechecking-with-proptypes.html에서 PropTypes에 대한 더 다양한 활용법 확인 가능
